
조인검색



나중에 배울 것 sql 함수

기본적인 SQL입력 방법, 문법을 알아야함
데이터베이스 연결하는 법도 - 이클립스와 연동안됨;
데이터에 자료 업뎃하기



-- HR



-- 15. 급여가 12000 이상되는 직원들의 LAST_NAME 및 급여를 조회한다. 


              SELECT LAST_NAME, SALARY FROM EMPLOYEES;

              ↓

              SELECT LAST_NAME, SALARY FROM EMPLOYEES
              WHERE SALARY >= 12000
              ODER BY SALARY DESC;


-- 16. 사원번호가 176 인 사람의 LAST_NAME 과 부서 번호를 조회한다.

              SELECT LAST_NAME, DEPARTMENT_ID FROM EMPLOYEES;
              
              ↓
              
              SELECT LAST_NAME, DEPARTMENT_ID FROM EMPLOYEES;
              WHERE EMPLOYEE_ID = 176;


-- 17. 급여가 5000 에서 12000의 범위 이외인 사람들의 LAST_NAME 및 급여를 조회한다.
              
              SELECT LAST_NAME, SALARY FROM EMPLOYEES;
              
              SELECT LAST_NAME, SALARY FROM EMPLOYEES
              WHERE SALARY < 5000 OR SALARY > 12000;
             
                    //5보다 작고 12보다는 커야하므로 AMD가 아니라 OR로 연결함!
                    // <- 1 2 3 4  ㅣ_____↔____ ㅣ 13 14 15 16 ->

              SELECT LAST_NAME, SALARY FROM EMPLOYEES
              WHERE SALARY < 5000 OR SALARY > 12000;
              ORDER BY SALARY;
              


-- 18. 20 번 또는 50 번 부서에 근무하며, 급여가 5000 ~ 12,000 사이인 사원들의 LAST_NAME 및 급여을 조회한다.

             SELECT LAST_NAME, SALARY FROM EMPLOYEES
             WHERE DEPARTMENT_ID IN (20,50);

              ↓
              
             SELECT LAST_NAME, DEPARTMNET_ID, SALARY 
             FROM EMPLOYEES
             WHERE DEPARTMENT_ID IN (20,50)
             AND SALARY BETWEEN 5000 AND 12000;
             ORDER BY DEPARTMENT_ID, SALARY;


-- 19. LAST_NAME 의 네번째 글자가 a인 사원들의 LAST_NAME 을 조회한다.


            SELECT LAST_NAME  FROM EMPLOYEES
            WHERE LAST_NAME LIKE'___a%';
          
          

-- 20. LAST_NAME 에 a 및/또는 e 글자가 있는 사원들의 LAST_NAME 을 조회힌다.

            SELECT LAST_NAME  FROM EMPLOYEES
            WHERE LAST_NAME LIKE '%a%' OR LAST NAME LIKE '%e%';
            -- 85

            SELECT LAST_NAME  FROM EMPLOYEES
            WHERE LAST_NAME LIKE '%a%' AND LAST NAME LIKE '%e%';
            -- 20
           
           
           
-- 21. 급여가 2500, 3500, 7000 이 아니며 직업이 SA_REP 이나 ST_CLERK 인 사람들을 조회한다.
            
            
            SELECT JOB_ID, SALARY FROM EMPLOYEES;
            
            ↓
            
            SELECT JOB_ID, SALARY FROM EMPLOYEES
            WHERE SALARY NOT IN (2500,3500,7000);
            
            ↓
            
            SELECT JOB_ID, SALARY FROM EMPLOYEES
            WHERE SALARY NOT IN (2500,3500,7000) AND
            JOB_ID IN ('SA_REP', 'ST_CLERK');
            ORDER BY JOB_ID , SALARY;
            
            
            
-- 22. 부서번호별 사원수를 조회하라. (부서번호 오름차순 정렬)
            
            SELECT COUT(EMPLOYEE_ID) 사원수 
                           -- ↑ PK를 넣어야함
            FROM EMPLOYEES
            GROUP BY DEPARTMENT_ID
            ORDER BY DEPARTMNET _ID;
                         
             
-- 23. 직무 아이디별 평균 급여를 조회하라. (직무 아이디 내림차순 정렬)
            
           SELECT JOB_ID, AVG(SALARY) 평균급여 FROM EMPLOYEES
           GROUP BY JOB_ID
           ORDER BY JOB_ID DESC; -- 내림차순 정렬
             
             
             
-- 24. 상사가 있는 사원들의 모든 정보를 조회하라.
            
            SELECT * FROM EMPLOYEES
            WHERE MANAGER_ID IS NOT NULL;
            
            
  
-- 25. 상사가 없는 사원들의 모든 정보를 조회하라.


            SELECT * FROM EMPLOYEES
            WHERE MANAGER_ID IS NULL;
            
            

-- 26. IT 부서의 급여 총합을 조회하라.

            -- 직책으로 찾기
            SELECT FROM EMPLOYEES
            WRERE JOB_ID LIKE 'IT%';             
            SELECT SUM(SALARY) 급여총합 FROM EMPLOYEES
            WRERE JOB_ID LIKE 'IT%';
            
            -- 부서로 찾기
            SELECT FROM EMPLOYEES
            WRERE JOB_ID LIKE 'IT%'; 
            SELECT SUM(SALARY) 급여총합 FROM EMPLOYEES
            WRERE DEPARTMENT_ID IN (60, 210, 230);

-- 27. 부서와 직무별 최대급여, 최소급여, 사원수를 조회하라.
            
                         
             SELECT DEPARTMENT_ID, JOB_ID, 
             MAX(SALARY)  최대급여 , MIN(SALARY) 최소급여,
             COUNT(EMPLOYEE_ID) 사원수
             FROM EMPLOYEES
             WHERE DEPARTMENT_ID IS NOT NULL; -- 부서 미소속 사원 제외하기
             GROUP BY DEPARTMENT_ID, JOB_ID;
             
            -- WHERE 절은 프롬과 그룹 바이 사이에 간다.
            -- FROM / WHERE / HAVING / GROUP BY 순으로 작성한다

            
                //이건 그냠 참조
                SELECT JOB_ID, COUNT(EMPLOYEE_ID) 총사원수
                 FROM EMPLOYEES
                 GROUP BY JOB_ID;
                 ↓
                 SELECT JOB_ID, COUNT(EMPLOYEE_ID) 총사원수
                 FROM EMPLOYEES
                 GROUP BY JOB_ID
                 HAVING JOB_ID LIKE '%MGR';

-- 28. 회사 전체의 최대 급여, 최소급여, 급여 총합 및 평균 급여를 조회하세요
            
                         
             
            

-- 29. 각 JOB_ID 별, 최대 급여, 최소 급여, 급여 총합 및 평균 급여를 정수로 포맷하여 조회하세요
            
                         
             
                         
             
-- 30. 직책별 사원 총 수를 조회하세요
            
                 SELECT JOB_ID, COUT(EMPLOYEE_ID) 총사원수
                 FROM EMPLOYEES
                 GROUP BY JOB_ID;
                         
                         
             
-- 31. 매니저로 근무하는 사원들의 총 수를 조회하세요

                                     
            SELECT COUNT (MANAGER_ID) 매니저사원수 FROM EMPLOYEES;
            
            
            ↓
            SELECT COUNT (DESC MANAGER_ID) 매니저사원수 
            FROM EMPLOYEES;
                        -- 매니저 ID 갖고 있는 직원으로 조회
                        
                        
                        
             
-- 32. 사내의 최대 급여 및 최소 급여의 차이를 조회하세요
            
                        
              SELECT MAX (SALARY)최대급여 , MIN(SALARY) 최소급여,
              MAX(SALARY) - MIN (SALARY) 급여차
              FROM EMPLOYEES;
             



// ----------------------------------------------------------------------------------



도서 가격을 내림 차순으로 같은 출판사 이름으로 오름차순

              SELECT PRICR, PUBLISHER FROM BOOKS
              ODER BY PRICE DESC, PUBLISHER;


고객이 주문한 도서 총 평균 최고 판매액 조회하시오

              SELECT SUM(SALEPRISE), AVG(SALEPRICE), MAX(SALEPRICE), MIN (SALEPRICE) 
              FROM BOOKORDERS;

                    고객 별 아냐?
              SELECT SUM(SALEPRISE) 총, AVG(SALEPRICE) 평균 , MAX(SALEPRICE) 최대, MIN (SALEPRICE) 최소 
              FROM BOOKORDERS
              GROUP BY CUSTID;



출판사별 도서의 총수량 조회  

              SELECT PUBLISHER, COUNT (BOOKID) 수량 FROM BOOKS
              GROUP BY PUBLISHER;




출판사별 도서의 총 수량이 2권 이상인 출판사를 조회


              SELECT PUBLISHER, COUNT (BOOKID) 수량 FROM BOOKS
              GROUP BY PUBLISHER;
                              -- HAVING은 조건절 
              HAVING 수량 >=2
              ORDER BY 수량;
              



가격이 8000원 이상인 도서를 구매한 고객별 주문 도서의 총수량은?

            8000원 이상 구매한 고객들을 추려서 총 수량을 내자
            
            SELECT FROM BOOKORDERS 
            WHERE SALEPRICE >= 8000;
           
           ↓
            SELECT CUSTID, COUNT(BOOKID) 수량
            FROM BOOKORDERS
            WHERE SALEPRICE >= 8000
            GROUP BY CUSTID;


가격이 8000원 이상인 도서를 구매한 고객별 주문 도서의 총수량은?
고객별 두권 이상 주문한 고객을 조회하시오
           
            SELECT CUSTID, COUNT(BOOKID) 수량
            FROM BOOKORDERS
            WHERE SALEPRICE >= 8000
            GROUP BY CUSTID
            HAVING 수량 >= 2;
            




-- ____________________________________________________//



 << 조인 검색 >>

조인검색이란  여러 테이블에서 불러오는 검색 = 카테시안 곱

                 [주문테이블]                             [제품테이블]
주문번호 / 고객/ 수량/ 제품명 /배송지/ 주문일  <->  제품번호 / 제품명 / 재고량
                                             ↓
                                    000 고객의 주문서


 조인검색의 조건
 SELECT * FROM  테이블명 별칭 , 테이블명 1 별칭1 , 테이블명2 별칭2 ,
 WHERE 별칭1 . 키 = 별칭2 . 키 ;


내부조인인 이너조인 (테이블들 간의 교집합)
SELECT * FROM 테이블명 1 별칭1 INEER JOIN  테이블명2 별칭2
USING (공통컬럼명);


조인의 외부 요소들을 조회할땐 아우터조인 (테이블들 간의 차집합)




 -- 7-37

           SELECT * FROM ORDERS O, PRODUCTS P; -- 카테시안 곱

           ↓

           SELECT * FROM ORDERS O, PRODUCTS P
           WHERE ORDERS . PRODID = PRODUCTS . PRODID;
           -- 곱연산 후 필터링 적용

           ↓

           SELECT * FROM ORDERS O, PRODUCTS P 
           WHERE O . PRODID = P . PRODID;
           --약어로 만든 별칭을 쓰면 더 간단해짐!


 BANANA 고객님의 주문건을 볼까?

           SELECT P.NAME FROM ORDERS O, PRODUCTS P 
           WHERE O.PRODID = P.PRODID;  -- 테이블 결합문 
           AND CUSTID = 'BANANA';  -- 검색 조건절






 검색절과와 결합문 분간이 잘 안되잖음
 WHERE절을 SQL 문법인 INNER JOIN ( 내부 결합)으로 변경해서 써보자
 
 INNER JOIN은 내부에서 합친다는 의미라서 교집합을 의미함.

 
 SELECT * FROM 테이블명 1 별칭1 INEER JOIN  테이블명2 별칭2
USING (공통컬럼명);
 
 
 
 
 바나나 고객님의 주문건을 이너 조인 유징으로 정리해보자
 
            SELECT P.NAME 
            FROM ORDERS O INNER JOIN PRODUCTS P
            USING (PRODID)
            WHERE CUSTID = 'BANANA';  



-- 컬럼명이 다를 경우 
SELECT * FROM 
테이블명 1 별칭1 INEER JOIN  테이블명2 별칭2
 ON 별칭1.컬럼명1 = 별칭2.컬럼명2; 
          



-- 이너 조인과 온
              
 
            SELECT P.NAME 
            FROM ORDERS O INNER JOIN PRODUCTS P
            ON O.PRODID = P.PRODID
            WHERE CUSTID = 'BANANA';  




-- 7-38

            WHERE 절로 쓴 작성과 
            INNER JOIN과 USING 문을 쓴 작성 


            SELECT * FROM ORDERS O INNER JOIN CUSTOMERS C
            ON O.CUSTID = C.CUSTID;
            
            SELECT D.PRODID, 0.ORDDATE FROM
            OERDERS O INNER JOI CUSTOMERS C
            ON O.CUSTID = C.CUSTID;
            USING (CUSTID(
            WHERE C.AGE >= 30; 
            
            
- 7-39 

            SELECT *  FROM CUSTOMERS C INNER JOIN ORDERS O
            USING (CUSTID);


            SELECT *  FROM CUSTOMERS C INNER JOIN ORDERS O
            USING (CUSTID) 
            INNER JOIN PRODUCTS P USING (PRODID);
            
            
            
            
고명석 고객이 주문한 상품명은?
            SELECT P.NAME  FROM CUSTOMERS C INNER JOIN ORDERS O
            USING (CUSTID) 
            INNER JOIN PRODUCTS P USING (PRODID);
            WHERE C.CUSTID = '고명석';
            
            
            
            
            
            
            
            





-- ---------------------------------------- //


books



15. 고객과 고객의 주문에 관한 데이터를 고객번호 순으로 정렬하여 보이시오

      SELECT * FROM 
      BOOKMEMBERS BM INNER JOIN BOOKORDERS BO
      USING (CUSTID)
      ORDER BY CUSTID;


16. 고객의 이름과 고객이 주문한 도서의 판매가격을 검색하시오

    SELECT BM.NAME, BO.SALEPRICE
    FROM BOOKMEMBERS BM INNER JOIN BOOKORDERS BO
    USING (CUSTID)


17. 고객별로 주문한 모든 도서의 총 판매액을 구하고, 고객별로 정렬하시오.

        조인 후에 그룹바이를 하자
        
        
        SET SQL_MODE = 'ONLY_FULL_GROUP_BY';
        SELECT  BM.NAME, SUM(SALEPRICE) 총판액
        FROM BOOKMEMEBERS BM INNER JOIN BOOKORDERS BO
        USING (CUSTID)
        GROUP BY BM.NAME; -- 동명이인이 없다는 전제하에..
                              CUSTID로는 숫자만 떠서 누가 누군지 몰라.
                              
                              
18. 고객의 이름과 고객이 주문한 도서의 이름을 구하시오.

        -카테시안 곱 쓸 때
        SELECT BM.NAME, B.BOOKNAME FROM 
        BOOKMEMNERS BM, BOOKORDERS BO, BOOKS B
        WHERE BM.CUSTID = BO.CUSTID AND BO.BOOKID = B.BOOKID; 
        -- 이너조인 USING을 안쓰면 복잡해져...
        
        
        이너조인 유징쓸 때
        SELECT BM.NAME, B.BOOKNAME FROM 
        BOOKMEMNERS BM INNER JOIN BOOKORDERS BO, BOOKS B
        USING (CUSTID) = BO.CUSTID
        USING (BOOKID);
        
        SELECT BM.NAME, B.BOOKNAME FROM 
        BOOKMEMNERS BM INNER JOIN BOOKORDERS BO
        ON BO.CUSTID = BO.CUSTID INNER JOIN BOOKS B
        ON BO.BOOKID = B.BOOKID;



19. 가격이 20,000원인 도서를 주문한 고객의 이름과 도서의 이름을 구하시오.


        
        SELECT BM.NAME, B.BOOKNAME FROM 
        BOOKMEMNERS BM INNER JOIN BOOKORDERS BO, BOOKS B
        USING (CUSTID) = BO.CUSTID
        USING (BOOKID)
        WHERE BO. SALEPRICE = 20000;
        
        


-- HR //--------------------------------------------------------------


33. 모든 사원들의 LAST_NAME, 부서 이름 및 부서 번호을 조회하세요
        
        
        SELECT LAST_NAME, DEPARTMENT_NAME, DEPARTMENT_ID
        FROM
        EMPOLYEES E INNER JOIN DEPARTMENT D
        USING (DEPARTMENT_ID)
        ORDER BY DEPARTMENT_ID;





34. 부서번호 30의 모든 직업들과 부서명으로 조회하세요. 90 부서 또한 포함한다.

            SELECT JOB_ID, DEPARTMENT_NAME
            FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
            USING (DEPARTMENT_ID)
            WHERE DEPARTMENT_ID IN (30,90);
            
            

35. 부서번호 30 이하의 모든 직업들과 부서명으로 조회하세요 

            SELECT JOB_ID, DEPARTMENT_NAME
            FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
            USING (DEPARTMENT_ID)
            WHERE DEPARTMENT_ID <= 30;
            


36. 커미션을 버는 모든 사람들의 LAST_NAME, 부서명, 지역 ID 및 도시 명을 조회하세요

            SELECT LAST_NAME, DEPARTMENT_NAME, LOCARION_ID, CITY
            FROM EMPLOYEES E INNNER JOIN DEPARTMENTS D
            USING (DEPARTMNET_ID) INNER JOIN LOCATIONS L
            USING (LOCATION_ID)
            WHERE COMMSSION_PCT IN NOT NULL;




37. 시애틀에 사는 사람 중 커미션을 버는 모든 사람들의 LAST_NAME, 부서명, 지역 ID 및 도시 명을 조회하세요






-- OUTTER JOIN 

-- 한번도 주문하지 않은 고객을 조회하기

-- 한번도 안팔린 상품 조회하기
            
